#!/bin/bash

# gitsync
# A script to automate Git commit, pull, and push workflows
# for multiple GitHub accounts using dedicated SSH keys.
# Also provides a --update-readme command to regenerate the README scripts table.
# This variant will run update_readme automatically only when a commit was created during sync.

# --- Configuration ---
LOG_FILE="$HOME/gitsync.log"
GIT_ID_FILE=".git_ID"
SSH_DIR="$HOME/.ssh"

# --- Helper Functions ---
log_message() {
  local level="$1"; local message="$2"
  local timestamp; timestamp=$(date '+%Y-%m-%d %H:%M:%S')
  local log_entry="$timestamp [$level] $message"
  echo "$log_entry" >> "$LOG_FILE"
  echo "$log_entry"
}

check_git_repo() {
  if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    log_message "ERROR" "This is not a Git repository. Aborting."
    exit 1
  fi
  log_message "INFO" "Git repository verified."
}

get_account_details() {
  local abbrev="$1"
  case "$abbrev" in
    "df")
      GIT_USER_NAME="don-ferris"
      GIT_USER_EMAIL="dev@donferris.me"
      SSH_KEY_PATH="$SSH_DIR/id_ed25519-github-ssh-df"
      ;;
    "cx")
      GIT_USER_NAME="convergenx"
      GIT_USER_EMAIL="convergenx@donferris.me"
      SSH_KEY_PATH="$SSH_DIR/id_ed25519-github-ssh-cx"
      ;;
    "ncmm")
      GIT_USER_NAME="network-configurator-for-mere-mortals"
      GIT_USER_EMAIL="ncmm@donferris.me"
      SSH_KEY_PATH="$SSH_DIR/id_ed25519-github-ssh-ncmm"
      ;;
    "dlc")
      GIT_USER_NAME="digital-lifestyle-creations"
      GIT_USER_EMAIL="dev@digitallifestylecreations.com"
      SSH_KEY_PATH="$SSH_DIR/id_ed25519-github-ssh-dlc"
      ;;
    *)
      log_message "ERROR" "Unknown account abbreviation '$abbrev' in $GIT_ID_FILE."
      log_message "ERROR" "Valid abbreviations are: df, cx, ncmm, dlc."
      exit 1
      ;;
  esac
  log_message "INFO" "Configuring for account: $GIT_USER_NAME"
}

# --- README update helper ---
update_readme() {
  check_git_repo

  local README="README.md"
  local TMP; TMP=$(mktemp)

  log_message "INFO" "Building scripts table from top-level files..."

  cat > "$TMP" <<'EOF'
| File | Type | Description (first comment line if present) | Notes |
|---|---:|---|---|
EOF

  # List top-level files tracked or untracked at repo root
  mapfile -t files < <( (git ls-files --full-name | awk -F/ 'NF==1'; git ls-files --others --exclude-standard --full-name | awk -F/ 'NF==1') | sort -u )

  for name in "${files[@]}"; do
    case "$name" in
      README.md|.git*|.github|.gitignore) continue ;;
    esac
    [ -f "$name" ] || continue

    local ftype="file"
    if [[ "$name" == *.sh || ( -x "$name" && ! "$name" == *.md ) ]]; then
      ftype="script"
    elif [[ "$name" == *.ico ]]; then
      ftype="binary"
    elif [[ "$name" == *nanorc || "$name" == .aliases ]]; then
      ftype="config"
    fi

    local desc=""
    while IFS= read -r line; do
      local tline; tline="$(echo "$line" | sed -e 's/^[[:space:]]*//')"
      if [[ "$tline" =~ ^# ]]; then
        desc="$(echo "$tline" | sed -e 's/^#\+//; s/^[[:space:]]*//; s/[[:space:]]*$//')"
        break
      elif [[ -n "$tline" ]]; then
        break
      fi
    done < "$name"

    if [[ -z "$desc" ]]; then
      desc="(no header; inferred)"
    fi

    printf "| \`%s\` | %s | %s | %s |\n" "$name" "$ftype" "$desc" "" >> "$TMP"
  done

  local START_MARKER="<!-- SCRIPTS_TABLE_START -->"
  local END_MARKER="<!-- SCRIPTS_TABLE_END -->"

  if grep -q "$START_MARKER" "$README"; then
    local NEWREADME; NEWREADME=$(mktemp)
    awk -v start="$START_MARKER" -v end="$END_MARKER" -v tbl="$(cat "$TMP")" '
      BEGIN{inside=0}
      {
        if(index($0,start)){print $0; print tbl; inside=1; next}
        if(index($0,end)){print $0; inside=0; next}
        if(!inside) print $0
      }' "$README" > "$NEWREADME"
    mv "$NEWREADME" "$README"
    log_message "INFO" "README updated between markers."
  else
    {
      echo
      echo "$START_MARKER"
      cat "$TMP"
      echo "$END_MARKER"
    } >> "$README"
    log_message "INFO" "Markers not found; appended table to README."
  fi

  rm -f "$TMP"

  git add "$README"
  if git diff --staged --quiet; then
    log_message "INFO" "No changes to README to commit."
  else
    git commit -m "chore: update README scripts table"
    log_message "INFO" "Committed README update."
  fi
}

# --- Core Functions ---
sync_repo() {
  # make the function fail fast for errors we don't want to ignore
  set -e
  set -o pipefail

  log_message "INFO" "--- Starting Git Sync ---"
  check_git_repo

  log_message "INFO" "Staging all local changes (add, modify, delete)."
  git add --all

  if [ ! -f "$GIT_ID_FILE" ]; then
    log_message "ERROR" "Missing $GIT_ID_FILE in this directory."
    log_message "ERROR" "Please run '$0 --id' to initialize this repo or create the file manually."
    log_message "ERROR" "Format: [remote_repo_name] | [account_abbreviation]"
    exit 1
  fi

  local id_contents; id_contents=$(cat "$GIT_ID_FILE")
  local remote_repo_name; remote_repo_name=$(echo "$id_contents" | awk -F ' *\\| *' '{print $1}')
  local account_abbrev; account_abbrev=$(echo "$id_contents" | awk -F ' *\\| *' '{print $2}')

  if [ -z "$remote_repo_name" ] || [ -z "$account_abbrev" ]; then
    log_message "ERROR" "Invalid $GIT_ID_FILE format. Expected '[repo_name] | [abbrev]'."
    exit 1
  fi

  get_account_details "$account_abbrev"

  if [ ! -f "$SSH_KEY_PATH" ]; then
    log_message "ERROR" "SSH key not found at $SSH_KEY_PATH"
    exit 1
  fi

  export GIT_SSH_COMMAND="ssh -i $SSH_KEY_PATH -o IdentitiesOnly=yes"
  log_message "INFO" "Using SSH key: $SSH_KEY_PATH"

  git config user.name "$GIT_USER_NAME"
  git config user.email "$GIT_USER_EMAIL"
  log_message "INFO" "Set local Git config to $GIT_USER_NAME <$GIT_USER_EMAIL>"

  local expected_origin="git@github.com:$GIT_USER_NAME/$remote_repo_name.git"
  local current_origin; current_origin=$(git remote get-url origin 2>/dev/null || echo "")

  if [ "$current_origin" != "$expected_origin" ]; then
    log_message "WARN" "Remote 'origin' URL is incorrect."
    if [ -z "$current_origin" ]; then
      log_message "INFO" "Adding remote 'origin': $expected_origin"
      git remote add origin "$expected_origin"
    else
      log_message "INFO" "Updating remote 'origin' to: $expected_origin"
      git remote set-url origin "$expected_origin"
    fi
  else
    log_message "INFO" "Remote 'origin' is correct."
  fi

  local current_branch; current_branch=$(git rev-parse --abbrev-ref HEAD)
  log_message "INFO" "Syncing branch: $current_branch"

  local stash_needed=false
  if [ -n "$(git status --porcelain | grep '^\?\?')" ]; then
    stash_needed=true
  fi

  if [ "$stash_needed" = true ]; then
    log_message "INFO" "Stashing untracked files..."
    git stash push --keep-index --include-untracked -m "gitsync-temp-stash"
    log_message "INFO" "Temporary stash created."
  else
    log_message "INFO" "Working directory is clean of untracked files. No stash needed."
  fi

  # track whether we created a commit in this sync run
  local commit_made=false

  if ! git diff-index --quiet --cached HEAD --; then
    log_message "INFO" "Staged changes detected."
    local commit_message
    read -p "Enter commit message: " commit_message
    if [ -z "$commit_message" ]; then
      log_message "ERROR" "Commit message cannot be empty. Aborting."
      if [ "$stash_needed" = true ] && git stash list | grep -q "gitsync-temp-stash"; then
        git stash pop || log_message "WARN" "Could not pop stash on abort. Manual cleanup needed."
      fi
      exit 1
    fi
    log_message "INFO" "Committing staged changes..."
    git commit -m "$commit_message"
    commit_made=true
  else
    log_message "INFO" "No staged changes to commit."
  fi

  log_message "INFO" "Pulling remote changes with rebase..."
  git pull --rebase origin "$current_branch"

  log_message "INFO" "Pushing changes to origin $current_branch..."
  git push origin "$current_branch"

  if [ "$stash_needed" = true ] && git stash list | grep -q "gitsync-temp-stash"; then
    log_message "INFO" "Applying temporarily stashed changes..."
    if ! git stash pop; then
      log_message "WARN" "Could not automatically apply stash. Manual intervention required."
      exit 1
    fi
  fi

  # NEW: run README update only if we actually created a commit this run
  if [ "$commit_made" = true ]; then
    log_message "INFO" "Commit was made during this sync; regenerating README scripts table..."
    if ! update_readme; then
      log_message "WARN" "update_readme failed or returned an error."
    fi
  else
    log_message "INFO" "No commit was made during this sync; skipping README update."
  fi

  log_message "SUCCESS" "--- Sync complete for $GIT_USER_NAME/$remote_repo_name ---"
}

# --- Repo initialization --- (unchanged)
initialize_repos() {
  log_message "INFO" "--- Starting Repo Initialization ---"
  log_message "INFO" "Scanning $HOME for Git repositories. This may take a while..."

  exec 3< <(find "$HOME" -name ".git" -type d -prune \
             -not -path "*/.cache/*" \
             -not -path "*/.config/*" \
             -not -path "*/.local/*" \
             -not -path "*/node_modules/*" \
             -not -path "*/Library/*" \
             -not -path "*/Applications/*" \
             -not -path "*/Music/*" \
             -not -path "*/Movies/*" \
             -not -path "*/Pictures/*" \
             -not -path "*/Downloads/*" \
             2>/dev/null)

  while IFS= read -r git_dir <&3; do
      local repo_path
      repo_path=$(dirname "$git_dir")
      local id_file_path="$repo_path/$GIT_ID_FILE"

      echo
      log_message "INFO" "Found Git repo: $repo_path"

      if [ -f "$id_file_path" ]; then
        log_message "INFO" "Found existing $GIT_ID_FILE: $(cat "$id_file_path")"
        read -p "Overwrite? (y/N): " overwrite
        if [[ ! "$overwrite" =~ ^[Yy]$ ]]; then
          log_message "INFO" "Skipping."
          continue
        fi
      fi

      echo "Which GitHub account is this repo for?"
      local account_options=("df (don-ferris)" "cx (convergenx)" "ncmm (network...)" "dlc (digital...)" "skip")

      select opt in "${account_options[@]}"; do
        case "$opt" in
          "df (don-ferris)") local abbrev="df"; break ;;
          "cx (convergenx)") local abbrev="cx"; break ;;
          "ncmm (network...)") local abbrev="ncmm"; break ;;
          "dlc (digital...)") local abbrev="dlc"; break ;;
          "skip") local abbrev="skip"; break ;;
          *) echo "Invalid option $REPLY";;
        esac
      done

      if [ "$abbrev" == "skip" ]; then
        log_message "INFO" "Skipping $repo_path"
        continue
      fi

      local remote_name
      read -p "Enter the remote repository name (e.g., 'my-project'): " remote_name
      if [ -z "$remote_name" ]; then
        log_message "ERROR" "Remote name cannot be empty. Skipping."
        continue
      fi

      echo "$remote_name | $abbrev" > "$id_file_path"
      log_message "SUCCESS" "Created $id_file_path with content: '$remote_name | $abbrev'"
  done

  exec 3<&-

  log_message "INFO" "--- Repo Initialization Complete ---"
}

# --- Main script entry ---
show_usage() {
  echo "Usage: $0 [COMMAND]"
  echo
  echo "Commands:"
  echo "  (no command)      Syncs the current Git repository."
  echo "  --id              Initialize repos under \$HOME (create .git_ID files)."
  echo "  --update-readme   Generate/update README.md scripts table from top-level files and commit it."
  echo "  --help            Show this help message."
  echo
  echo "Log file: $LOG_FILE"
}

main() {
  case "${1:-}" in
    --id) initialize_repos ;;
    --update-readme) update_readme ;;
    --help) show_usage ;;
    "") sync_repo ;;
    *) log_message "ERROR" "Unknown command: $1"; show_usage; exit 1 ;;
  esac
}

main "$@"
