#!/usr/bin/env bash
#
# gitsync
# Automate add/commit/pull(rebase)/push across GitHub accounts; auto-stage new files, rebase remote changes, handle conflicts, and auto-update the README table after commits.

#
set -euo pipefail

# Configuration
LOG_FILE="${LOG_FILE:-$HOME/gitsync.log}"
GIT_ID_FILE="${GIT_ID_FILE:-.git_ID}"
SSH_DIR="${SSH_DIR:-$HOME/.ssh}"
REPO_OWNER="don-ferris"
REPO_NAME="bash-scripts"

# Logging helper
log_message() {
  local level="$1"; shift
  local message="$*"
  local timestamp
  timestamp=$(date '+%Y-%m-%d %H:%M:%S')
  local entry="$timestamp [$level] $message"
  printf '%s\n' "$entry" >> "$LOG_FILE"
  printf '%s\n' "$entry"
}

# Basic repo check
check_git_repo() {
  if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    log_message "ERROR" "This is not a Git repository. Aborting."
    exit 1
  fi
}

# Account mapping
get_account_details() {
  local abbrev="$1"
  case "$abbrev" in
    df)
      GIT_USER_NAME="don-ferris"
      GIT_USER_EMAIL="dev@donferris.me"
      SSH_KEY_PATH="$SSH_DIR/id_ed25519-github-ssh-df"
      ;;
    cx)
      GIT_USER_NAME="convergenx"
      GIT_USER_EMAIL="convergenx@donferris.me"
      SSH_KEY_PATH="$SSH_DIR/id_ed25519-github-ssh-cx"
      ;;
    ncmm)
      GIT_USER_NAME="network-configurator-for-mere-mortals"
      GIT_USER_EMAIL="ncmm@donferris.me"
      SSH_KEY_PATH="$SSH_DIR/id_ed25519-github-ssh-ncmm"
      ;;
    dlc)
      GIT_USER_NAME="digital-lifestyle-creations"
      GIT_USER_EMAIL="dev@digitallifestylecreations.com"
      SSH_KEY_PATH="$SSH_DIR/id_ed25519-github-ssh-dlc"
      ;;
    *)
      log_message "ERROR" "Unknown account abbreviation '$abbrev' in $GIT_ID_FILE."
      log_message "ERROR" "Valid abbreviations are: df, cx, ncmm, dlc."
      exit 1
      ;;
  esac
  log_message "INFO" "Configuring for account: $GIT_USER_NAME"
}

# === README update helper (fixed) ===
update_readme() {
  check_git_repo

  local README="README.md"
  local TMP
  TMP=$(mktemp) || return 1

  local BRANCH
  BRANCH="$(git rev-parse --abbrev-ref HEAD 2>/dev/null || true)"
  if [ -z "$BRANCH" ]; then BRANCH="main"; fi

  log_message "INFO" "Building scripts table from top-level files (File -> Description)..."

  # Single header row only
  cat > "$TMP" <<'TABLE_EOF'
| File | Description |
|---|---|
TABLE_EOF

  # Gather top-level files (tracked + untracked at repo root)
  mapfile -t files < <(
    {
      git ls-files --full-name | awk -F/ 'NF==1'
      git ls-files --others --exclude-standard --full-name | awk -F/ 'NF==1'
    } | sort -u
  )

  for name in "${files[@]}"; do
    # Skip README and common git metadata and directories
    case "$name" in
      README.md|.git*|.github|.gitignore) continue ;;
    esac
    [ -f "$name" ] || continue

    # Build GitHub blob URL pointing at current branch
    local url="https://github.com/${REPO_OWNER}/${REPO_NAME}/blob/${BRANCH}/${name}"
    local file_link="[\`${name}\`](${url})"

    # Extract description:
    # 1) Try to collect a top comment block (skip shebangs). If the first comment equals the filename, skip it.
    # 2) If no comment header, infer from first few non-comment lines (up to 3), then append " (no header; inferred)"
    local desc=""
    local first_comment_seen=0
    local include_from_here=0
    local -a infer_lines=()

    while IFS= read -r line; do
      # trim leading spaces
      local tline
      tline="$(printf '%s' "$line" | sed -e 's/^[[:space:]]*//')"

      # skip shebangs entirely
      if [[ "$tline" =~ ^#! ]]; then
        continue
      fi

      if [[ "$tline" =~ ^# ]]; then
        # comment line
        local comment
        comment="$(printf '%s' "$tline" | sed -e 's/^#\+//; s/^[[:space:]]*//; s/[[:space:]]*$//')"

        # If this is an empty comment (a line that is just "#" or "#   "), treat differently:
        # - If we haven't seen any comment yet, skip it as incidental (do not break)
        # - If we have already begun collecting comment lines, a blank comment means the comment block ends
        if [ -z "$comment" ]; then
          if [ "$first_comment_seen" -eq 1 ]; then
            break
          else
            # incidental blank comment above header — skip it
            continue
          fi
        fi

        if [ "$first_comment_seen" -eq 0 ]; then
          first_comment_seen=1
          # compare lowercase to filename
          local lc_comment lc_name
          lc_comment="$(printf '%s' "$comment" | tr '[:upper:]' '[:lower:]')"
          lc_name="$(printf '%s' "$name" | tr '[:upper:]' '[:lower:]')"
          if [ "$lc_comment" = "$lc_name" ]; then
            # skip this first comment line equal to filename; start including subsequent comment lines
            include_from_here=1
            desc=""
            continue
          else
            include_from_here=1
            desc="$comment"
            continue
          fi
        else
          if [ "$include_from_here" -eq 1 ]; then
            desc="${desc:+$desc }${comment}"
            continue
          else
            break
          fi
        fi
      else
        # non-comment line
        if [ "$first_comment_seen" -eq 1 ]; then
          # we've already collected a comment block; stop
          break
        else
          # no comment block; gather inference lines (up to 3)
          if [ -n "$tline" ]; then
            infer_lines+=("$tline")
            if [ "${#infer_lines[@]}" -ge 3 ]; then
              break
            fi
          fi
        fi
      fi
    done < "$name"

    if [ -z "$desc" ] && [ "${#infer_lines[@]}" -gt 0 ]; then
      # create an inferred description from the first non-comment lines
      local joined
      joined="$(printf '%s ; ' "${infer_lines[@]}" | sed 's/ ; $//')"
      if [ "${#joined}" -gt 220 ]; then
        joined="${joined:0:217}..."
      fi
      desc="${joined} (no header; inferred)"
    fi

    if [ -z "$desc" ]; then
      desc="(no header; inferred)"
    fi

    # Escape pipe characters so the Markdown table stays valid
    desc="${desc//|/\\|}"

    printf "| %s | %s |\n" "$file_link" "$desc" >> "$TMP"
  done

  local START_MARKER="<!-- SCRIPTS_TABLE_START -->"
  local END_MARKER="<!-- SCRIPTS_TABLE_END -->"

  # Remove legacy 4-column table block if present between BEGIN/END markers
  if grep -qF '<!-- BEGIN SCRIPTS -->' "$README" && grep -qF '<!-- END SCRIPTS -->' "$README"; then
    # delete the entire legacy block
    sed -i '/<!-- BEGIN SCRIPTS -->/,/<!-- END SCRIPTS -->/d' "$README"
    log_message "INFO" "Removed legacy BEGIN/END SCRIPTS block from README."
  fi

  if grep -qF "$START_MARKER" "$README"; then
    # Replace content between markers with our table
    local NEWREADME
    NEWREADME=$(mktemp) || { rm -f "$TMP"; return 1; }

    awk -v start="$START_MARKER" -v end="$END_MARKER" -v tblfile="$TMP" '
      {
        lines[NR] = $0
      }
      END {
        for (i = 1; i <= NR; i++) {
          if (index(lines[i], start)) {
            # print up to the start marker line
            for (j=1;j<=i;j++) print lines[j]
            # print table from tmp file
            while ((getline t < tblfile) > 0) print t
            # skip forward to end marker, print it and the rest
            k = i+1
            while (k <= NR && index(lines[k], end) == 0) k++
            if (k <= NR) {
              print lines[k]
              for (j = k+1; j <= NR; j++) print lines[j]
            }
            exit
          }
        }
        # start marker not found in the loop above — fallback to printing all
        for (i=1;i<=NR;i++) print lines[i]
      }' "$README" > "$NEWREADME"

    mv "$NEWREADME" "$README"
    log_message "INFO" "README updated between markers."
  else
    # Append markers + table
    {
      echo
      echo "$START_MARKER"
      cat "$TMP"
      echo "$END_MARKER"
    } >> "$README"
    log_message "INFO" "Markers not found; appended table to README."
  fi

  rm -f "$TMP"

  # Stage, commit and push README if changed
  git add "$README"
  if git diff --staged --quiet; then
    log_message "INFO" "No changes to README to commit."
    return 0
  else
    git commit -m "chore: update README scripts table"
    log_message "INFO" "Committed README update."
    local branch
    branch="$(git rev-parse --abbrev-ref HEAD 2>/dev/null || true)"
    if [ -z "$branch" ]; then branch="main"; fi
    git push origin "$branch"
    log_message "INFO" "Pushed README update to origin/$branch"
  fi
}

# === Conflict handling helper (unchanged) ===
handle_rebase_conflict() {
  local branch="$1"
  echo
  echo "gitsync: pull --rebase failed (likely conflicts). Choose an option:"
  echo "  [A] Auto-recover: abort rebase, stash (incl untracked), pull/rebase, pop stash and auto-commit if clean"
  echo "  [B] Manual: drop to a shell so you can resolve conflicts (then run 'git rebase --continue')"
  echo "  [C] Abort: run 'git rebase --abort' and exit"
  printf "Select [A/B/C]: "
  IFS= read -r -n 1 choice
  printf "\n"
  choice="${choice^^}"

  case "$choice" in
    A)
      log_message "INFO" "Attempting automatic recovery..."
      git rebase --abort >/dev/null 2>&1 || true
      local stash_name="gitsync-auto-recovery-$(date +%Y%m%d%H%M%S)"
      git stash push --include-untracked -m "$stash_name"
      if git pull --rebase origin "$branch"; then
        log_message "INFO" "Pull/rebase succeeded after stashing."
        if git stash list | grep -qF "$stash_name"; then
          if git stash pop; then
            log_message "INFO" "Stash popped successfully."
            git add --all
            if ! git diff --cached --quiet; then
              git commit -m "chore: restore local changes after rebase (auto)"
              log_message "INFO" "Committed restored local changes."
            fi
            return 0
          else
            log_message "WARN" "Conflicts occurred while popping stash. Please resolve manually."
            return 1
          fi
        fi
        return 0
      else
        log_message "ERROR" "Automatic pull/rebase after stashing failed."
        return 1
      fi
      ;;
    B)
      log_message "INFO" "Entering interactive shell for manual resolution. Resolve conflicts, then run 'git rebase --continue'."
      $SHELL
      return 0
      ;;
    C)
      log_message "INFO" "Aborting rebase and exiting."
      git rebase --abort >/dev/null 2>&1 || true
      return 2
      ;;
    *)
      log_message "WARN" "Invalid choice; aborting."
      return 2
      ;;
  esac
}

# --- Main sync flow (unchanged behavior) ---
sync_repo() {
  check_git_repo

  if [ ! -f "$GIT_ID_FILE" ]; then
    log_message "ERROR" "Missing $GIT_ID_FILE in this directory."
    log_message "ERROR" "Please run '$0 --id' to initialize this repo or create the file manually."
    log_message "ERROR" "Format: [repo_name] | [abbrev]"
    exit 1
  fi

  local id_line
  id_line="$(grep -v '^[[:space:]]*#' "$GIT_ID_FILE" | sed -n '1p' || true)"
  if [ -z "$id_line" ]; then
    log_message "ERROR" "$GIT_ID_FILE does not contain a valid mapping line (after skipping comments)."
    exit 1
  fi

  local remote_repo_name account_abbrev
  remote_repo_name="$(printf '%s' "$id_line" | awk -F ' *\\| *' '{print $1}')"
  account_abbrev="$(printf '%s' "$id_line" | awk -F ' *\\| *' '{print $2}')"

  if [ -z "$remote_repo_name" ] || [ -z "$account_abbrev" ]; then
    log_message "ERROR" "Invalid $GIT_ID_FILE format. Expected '[repo_name] | [abbrev]'."
    exit 1
  fi

  get_account_details "$account_abbrev"

  if [ ! -f "$SSH_KEY_PATH" ]; then
    log_message "ERROR" "SSH key not found at $SSH_KEY_PATH"
    exit 1
  fi

  export GIT_SSH_COMMAND="ssh -i $SSH_KEY_PATH -o IdentitiesOnly=yes"
  git config user.name "$GIT_USER_NAME"
  git config user.email "$GIT_USER_EMAIL"

  local branch
  branch="$(git rev-parse --abbrev-ref HEAD 2>/dev/null || true)"
  if [ -z "$branch" ]; then branch="main"; fi

  local expected_origin="git@github.com:${GIT_USER_NAME}/${remote_repo_name}.git"
  local current_origin
  current_origin="$(git remote get-url origin 2>/dev/null || true)"

  if [ "$current_origin" != "$expected_origin" ]; then
    log_message "WARN" "Remote 'origin' URL is incorrect or missing."
    if [ -z "$current_origin" ]; then
      log_message "INFO" "Adding remote 'origin': $expected_origin"
      git remote add origin "$expected_origin"
    else
      log_message "INFO" "Updating remote 'origin' to: $expected_origin"
      git remote set-url origin "$expected_origin"
    fi
  fi

  # Auto-track new files: stage everything
  log_message "INFO" "Staging all changes (including new files)."
  git add --all

  local commit_made=false

  if ! git diff --cached --quiet; then
    log_message "INFO" "Staged changes detected."
    local commit_message
    read -r -p "Enter commit message: " commit_message
    if [ -z "$commit_message" ]; then
      log_message "ERROR" "Commit message cannot be empty. Aborting."
      exit 1
    fi
    git commit -m "$commit_message"
    commit_made=true
  else
    log_message "INFO" "No staged changes to commit."
  fi

  log_message "INFO" "Pulling remote changes with rebase..."
  if git pull --rebase origin "$branch"; then
    log_message "INFO" "Pull/rebase succeeded."
  else
    log_message "ERROR" "Pull/rebase failed (conflicts?)."
    handle_rebase_conflict "$branch"
    local rc=$?
    if [ "$rc" -eq 0 ]; then
      log_message "INFO" "Conflict handling succeeded; continuing."
    elif [ "$rc" -eq 1 ]; then
      log_message "WARN" "Recovery attempted but unresolved conflicts remain. Please resolve manually."
      exit 1
    else
      log_message "INFO" "User aborted conflict handling. Exiting."
      exit 0
    fi
  fi

  log_message "INFO" "Pushing changes to origin/$branch..."
  git push origin "$branch"

  if [ "$commit_made" = true ]; then
    log_message "INFO" "Local commit created; regenerating README table..."
    if ! update_readme; then
      log_message "WARN" "update_readme failed or returned an error."
    fi
  else
    log_message "INFO" "No local commit created; skipping README update."
  fi

  log_message "SUCCESS" "Sync complete for $GIT_USER_NAME/$remote_repo_name on branch $branch"
}

# Placeholder: initialization function if you use it
initialize_repos() {
  log_message "INFO" "initialize_repos called (placeholder)"
  :
}

show_usage() {
  cat <<'USAGE'
Usage: gitsync [COMMAND]

Commands:
  (no command)        Syncs current repository (auto-add, commit, pull --rebase, push).
  --id                Interactive repo initialization (create .git_ID files).
  --update-readme     Regenerate README table and commit+push it.
  --help              Show this help message.
USAGE
}

main() {
  case "${1:-}" in
    --id) initialize_repos ;;
    --update-readme) update_readme ;;
    --help) show_usage ;;
    "") sync_repo ;;
    *) log_message "ERROR" "Unknown command: $1"; show_usage; exit 1 ;;
  esac
}

main "$@"
