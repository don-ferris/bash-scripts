#!/usr/bin/env bash

# gitsync
# Automate Git add/commit/pull(rebase)/push workflows across multiple GitHub accounts.
# Includes: --update-readme (regenerate README table), auto-push README after update,
# automatic tracking of new files by default, and conflict-time interactive choices.
#
# Behavior summary (as requested):
# - New files are tracked automatically (git add --all) unless a problematic condition (rebase conflict) occurs.
# - The script only prompts interactively if a rebase/pull fails (conflict) so you can choose how to proceed.
# - README table updates are committed and pushed automatically when update_readme runs.
# - .git_ID may contain leading comment lines (headers); the first non-comment line is used for parsing.

set -euo pipefail

LOG_FILE="$HOME/gitsync.log"
GIT_ID_FILE=".git_ID"
SSH_DIR="$HOME/.ssh"

log_message() {
  local level="$1"; local message="$2"
  local timestamp; timestamp=$(date '+%Y-%m-%d %H:%M:%S')
  local entry="$timestamp [$level] $message"
  echo "$entry" >> "$LOG_FILE"
  echo "$entry"
}

check_git_repo() {
  if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    log_message "ERROR" "This is not a Git repository. Aborting."
    exit 1
  fi
  log_message "INFO" "Git repository verified."
}

get_account_details() {
  local abbrev="$1"
  case "$abbrev" in
    "df")
      GIT_USER_NAME="don-ferris"
      GIT_USER_EMAIL="dev@donferris.me"
      SSH_KEY_PATH="$SSH_DIR/id_ed25519-github-ssh-df"
      ;;
    "cx")
      GIT_USER_NAME="convergenx"
      GIT_USER_EMAIL="convergenx@donferris.me"
      SSH_KEY_PATH="$SSH_DIR/id_ed25519-github-ssh-cx"
      ;;
    "ncmm")
      GIT_USER_NAME="network-configurator-for-mere-mortals"
      GIT_USER_EMAIL="ncmm@donferris.me"
      SSH_KEY_PATH="$SSH_DIR/id_ed25519-github-ssh-ncmm"
      ;;
    "dlc")
      GIT_USER_NAME="digital-lifestyle-creations"
      GIT_USER_EMAIL="dev@digitallifestylecreations.com"
      SSH_KEY_PATH="$SSH_DIR/id_ed25519-github-ssh-dlc"
      ;;
    *)
      log_message "ERROR" "Unknown account abbreviation '$abbrev' in $GIT_ID_FILE."
      log_message "ERROR" "Valid abbreviations are: df, cx, ncmm, dlc."
      exit 1
      ;;
  esac
  log_message "INFO" "Configuring for account: $GIT_USER_NAME"
}

# --- README update helper (no backup; pushes README after commit) ---
update_readme() {
  check_git_repo

  local README="README.md"
  local TMP; TMP=$(mktemp) || return 1

  log_message "INFO" "Building scripts table from top-level files..."

  cat > "$TMP" <<'EOF'
| File | Type | Description (first comment line if present) | Notes |
|---|---:|---|---|
EOF

  mapfile -t files < <( (git ls-files --full-name | awk -F/ 'NF==1'; git ls-files --others --exclude-standard --full-name | awk -F/ 'NF==1') | sort -u )

  for name in "${files[@]}"; do
    case "$name" in
      README.md|.git*|.github|.gitignore) continue ;;
    esac
    [ -f "$name" ] || continue

    local ftype="file"
    if [[ "$name" == *.sh || ( -x "$name" && ! "$name" == *.md ) ]]; then
      ftype="script"
    elif [[ "$name" == *.ico ]]; then
      ftype="binary"
    elif [[ "$name" == *nanorc || "$name" == .aliases ]]; then
      ftype="config"
    fi

    local desc=""
    while IFS= read -r line; do
      local tline; tline="$(echo "$line" | sed -e 's/^[[:space:]]*//')"
      # skip shebangs like #!/bin/bash
      if [[ "$tline" =~ ^#! ]]; then
        continue
      fi
      if [[ "$tline" =~ ^# ]]; then
        desc="$(echo "$tline" | sed -e 's/^#\+//; s/^[[:space:]]*//; s/[[:space:]]*$//')"
        break
      elif [[ -n "$tline" ]]; then
        break
      fi
    done < "$name"

    if [[ -z "$desc" ]]; then
      desc="(no header; inferred)"
    fi

    printf "| \`%s\` | %s | %s | %s |\n" "$name" "$ftype" "$desc" "" >> "$TMP"
  done

  local START_MARKER="<!-- SCRIPTS_TABLE_START -->"
  local END_MARKER="<!-- SCRIPTS_TABLE_END -->"

  if grep -q "$START_MARKER" "$README"; then
    local NEWREADME; NEWREADME=$(mktemp) || { rm -f "$TMP"; return 1; }
    awk -v start="$START_MARKER" -v end="$END_MARKER" -v tbl="$(cat "$TMP")" '
      BEGIN{inside=0}
      {
        if(index($0,start)){print $0; print tbl; inside=1; next}
        if(index($0,end)){print $0; inside=0; next}
        if(!inside) print $0
      }' "$README" > "$NEWREADME"
    mv "$NEWREADME" "$README"
    log_message "INFO" "README updated between markers."
  else
    {
      echo
      echo "$START_MARKER"
      cat "$TMP"
      echo "$END_MARKER"
    } >> "$README"
    log_message "INFO" "Markers not found; appended table to README."
  fi

  rm -f "$TMP"

  # Stage and commit README; then push the commit
  git add "$README"
  if git diff --staged --quiet; then
    log_message "INFO" "No changes to README to commit."
    return 0
  else
    git commit -m "chore: update README scripts table"
    log_message "INFO" "Committed README update."
    local branch; branch="$(git rev-parse --abbrev-ref HEAD)"
    git push origin "$branch"
    log_message "INFO" "Pushed README update to origin/$branch"
  fi
}

# Handle a failed rebase/pull with interactive choices (only invoked on failure)
handle_rebase_conflict() {
  local branch="$1"
  echo
  echo "=== gitsync detected a rebase/pull failure (likely merge conflicts) ==="
  echo "Options:"
  echo "  [A] Attempt automatic recovery: abort rebase, stash local changes (incl. untracked), pull/rebase, pop stash and auto-commit local changes if applied cleanly."
  echo "  [B] Enter interactive shell to resolve conflicts manually (you must run: git rebase --continue or fix and commit)."
  echo "  [C] Abort: run 'git rebase --abort' and leave repository as before; exit."
  printf "Choose [A/B/C]: "
  IFS= read -r -n 1 choice
  printf "\n"
  choice="${choice^^}"

  case "$choice" in
    A)
      log_message "INFO" "User chose automatic recovery: attempting rebase abort, stash, pull, and restore."
      # Abort any in-progress rebase (safe if none)
      git rebase --abort >/dev/null 2>&1 || true
      local stash_name="gitsync-auto-recovery-$(date +%Y%m%d%H%M%S)"
      git stash push --include-untracked -m "$stash_name"
      log_message "INFO" "Stashed local changes as $stash_name"
      if git pull --rebase origin "$branch"; then
        log_message "INFO" "Pull/rebase succeeded after stashing."
        # Try to pop stash
        if git stash list | grep -q "$stash_name"; then
          if git stash pop; then
            log_message "INFO" "Stash popped successfully. Re-staging and committing local changes."
            git add --all
            if ! git diff --cached --quiet; then
              git commit -m "chore: restore local changes after rebase (auto)"
              log_message "INFO" "Committed restored local changes."
            else
              log_message "INFO" "No staged changes after stash pop."
            fi
            return 0
          else
            log_message "WARN" "git stash pop produced conflicts. Please resolve conflicts manually."
            echo "Conflicts occurred while applying the stash. Resolve them, then run 'git add <files>' and 'git rebase --continue' or 'git commit' as appropriate."
            return 1
          fi
        else
          log_message "INFO" "No stash entry found to pop (unexpected)."
          return 0
        fi
      else
        log_message "ERROR" "Automatic pull/rebase after stashing failed. Repository may require manual intervention."
        return 1
      fi
      ;;
    B)
      log_message "INFO" "Dropping into interactive shell for manual conflict resolution."
      echo "Interactive shell started. Resolve conflicts, then run: git rebase --continue"
      echo "When finished, exit the shell to allow gitsync to continue."
      $SHELL
      # After the shell, check if rebase is still in progress
      if git rebase --show-current-patch >/dev/null 2>&1; then
        log_message "WARN" "Rebase still in progress after returning from shell. Please finish it manually."
        return 1
      else
        log_message "INFO" "Assuming conflicts resolved. Continuing."
        return 0
      fi
      ;;
    C)
      log_message "INFO" "User chose abort. Running 'git rebase --abort' and exiting."
      git rebase --abort >/dev/null 2>&1 || true
      return 2
      ;;
    *)
      log_message "WARN" "Invalid option. Aborting."
      return 2
      ;;
  esac
}

# --- Core sync function ---
sync_repo() {
  log_message "INFO" "--- Starting Git Sync ---"
  check_git_repo

  # Ensure .git_ID present and parse first non-comment line
  if [ ! -f "$GIT_ID_FILE" ]; then
    log_message "ERROR" "Missing $GIT_ID_FILE in this directory."
    log_message "ERROR" "Please run '$0 --id' to initialize this repo or create the file manually."
    log_message "ERROR" "Format: [remote_repo_name] | [account_abbreviation]"
    exit 1
  fi
  local id_line
  id_line="$(grep -v '^[[:space:]]*#' "$GIT_ID_FILE" | sed -n '1p' || true)"
  if [ -z "$id_line" ]; then
    log_message "ERROR" "$GIT_ID_FILE does not contain a valid mapping line (after skipping comments)."
    exit 1
  fi
  local remote_repo_name; remote_repo_name="$(echo "$id_line" | awk -F ' *\\| *' '{print $1}')"
  local account_abbrev; account_abbrev="$(echo "$id_line" | awk -F ' *\\| *' '{print $2}')"

  if [ -z "$remote_repo_name" ] || [ -z "$account_abbrev" ]; then
    log_message "ERROR" "Invalid $GIT_ID_FILE format. Expected '[repo_name] | [abbrev]' on first non-comment line."
    exit 1
  fi

  get_account_details "$account_abbrev"

  if [ ! -f "$SSH_KEY_PATH" ]; then
    log_message "ERROR" "SSH key not found at $SSH_KEY_PATH"
    exit 1
  fi

  export GIT_SSH_COMMAND="ssh -i $SSH_KEY_PATH -o IdentitiesOnly=yes"
  log_message "INFO" "Using SSH key: $SSH_KEY_PATH"

  git config user.name "$GIT_USER_NAME"
  git config user.email "$GIT_USER_EMAIL"
  log_message "INFO" "Set local Git config to $GIT_USER_NAME <$GIT_USER_EMAIL>"

  local branch; branch="$(git rev-parse --abbrev-ref HEAD)"
  local expected_origin="git@github.com:$GIT_USER_NAME/$remote_repo_name.git"
  local current_origin; current_origin="$(git remote get-url origin 2>/dev/null || true)"

  if [ "$current_origin" != "$expected_origin" ]; then
    log_message "WARN" "Remote 'origin' URL is incorrect or missing."
    if [ -z "$current_origin" ]; then
      log_message "INFO" "Adding remote 'origin': $expected_origin"
      git remote add origin "$expected_origin"
    else
      log_message "INFO" "Updating remote 'origin' to: $expected_origin"
      git remote set-url origin "$expected_origin"
    fi
  else
    log_message "INFO" "Remote 'origin' is correct."
  fi

  # Default behavior: automatically track new files by staging everything
  log_message "INFO" "Auto-tracking new files: staging all changes now."
  git add --all

  # If there are staged changes, commit them
  local commit_made=false
  if ! git diff --cached --quiet; then
    log_message "INFO" "Staged changes detected."
    local commit_message
    read -p "Enter commit message: " commit_message
    if [ -z "$commit_message" ]; then
      log_message "ERROR" "Commit message cannot be empty. Aborting."
      exit 1
    fi
    git commit -m "$commit_message"
    commit_made=true
  else
    log_message "INFO" "No staged changes to commit."
  fi

  # Attempt pull with rebase; only prompt if rebase/pull fails (conflict)
  log_message "INFO" "Pulling remote changes with rebase..."
  if git pull --rebase origin "$branch"; then
    log_message "INFO" "Pull/rebase succeeded."
  else
    log_message "ERROR" "Pull/rebase failed (likely due to conflicts)."
    handle_rebase_conflict "$branch"
    local rc=$?
    if [ "$rc" -eq 0 ]; then
      log_message "INFO" "Recovery/interactive resolution succeeded; continuing."
    elif [ "$rc" -eq 1 ]; then
      log_message "WARN" "Recovery attempted but unresolved conflicts remain. Please resolve manually."
      exit 1
    else
      log_message "INFO" "User aborted during conflict handling. Exiting."
      exit 0
    fi
  fi

  # Push local commits (including README commit that update_readme will push)
  log_message "INFO" "Pushing changes to origin/$branch..."
  git push origin "$branch"

  # If we created a commit during this run, regenerate README (update_readme will commit+push)
  if [ "$commit_made" = true ]; then
    log_message "INFO" "Local commit was created during sync; regenerating README scripts table..."
    if ! update_readme; then
      log_message "WARN" "update_readme failed or returned an error."
    fi
  else
    log_message "INFO" "No local commit was created during this sync; skipping README update."
  fi

  log_message "SUCCESS" "--- Sync complete for $GIT_USER_NAME/$remote_repo_name on branch $branch ---"
}

# --- Repo initialization (unchanged) ---
initialize_repos() {
  log_message "INFO" "--- Starting Repo Initialization ---"
  log_message "INFO" "Scanning $HOME for Git repositories. This may take a while..."

  exec 3< <(find "$HOME" -name ".git" -type d -prune \
             -not -path "*/.cache/*" \
             -not -path "*/.config/*" \
             -not -path "*/.local/*" \
             -not -path "*/node_modules/*" \
             -not -path "*/Library/*" \
             -not -path "*/Applications/*" \
             -not -path "*/Music/*" \
             -not -path "*/Movies/*" \
             -not -path "*/Pictures/*" \
             -not -path "*/Downloads/*" \
             2>/dev/null)

  while IFS= read -r git_dir <&3; do
      local repo_path
      repo_path=$(dirname "$git_dir")
      local id_file_path="$repo_path/$GIT_ID_FILE"

      echo
      log_message "INFO" "Found Git repo: $repo_path"

      if [ -f "$id_file_path" ]; then
        log_message "INFO" "Found existing $GIT_ID_FILE: $(cat "$id_file_path")"
        read -p "Overwrite? (y/N): " overwrite
        if [[ ! "$overwrite" =~ ^[Yy]$ ]]; then
          log_message "INFO" "Skipping."
          continue
        fi
      fi

      echo "Which GitHub account is this repo for?"
      local account_options=("df (don-ferris)" "cx (convergenx)" "ncmm (network...)" "dlc (digital...)" "skip")

      select opt in "${account_options[@]}"; do
        case "$opt" in
          "df (don-ferris)") local abbrev="df"; break ;;
          "cx (convergenx)") local abbrev="cx"; break ;;
          "ncmm (network...)") local abbrev="ncmm"; break ;;
          "dlc (digital...)") local abbrev="dlc"; break ;;
          "skip") local abbrev="skip"; break ;;
          *) echo "Invalid option $REPLY";;
        esac
      done

      if [ "$abbrev" == "skip" ]; then
        log_message "INFO" "Skipping $repo_path"
        continue
      fi

      local remote_name
      read -p "Enter the remote repository name (e.g., 'my-project'): " remote_name
      if [ -z "$remote_name" ]; then
        log_message "ERROR" "Remote name cannot be empty. Skipping."
        continue
      fi

      echo "$remote_name | $abbrev" > "$id_file_path"
      log_message "SUCCESS" "Created $id_file_path with content: '$remote_name | $abbrev'"
  done

  exec 3<&-

  log_message "INFO" "--- Repo Initialization Complete ---"
}

show_usage() {
  cat <<'USAGE'
Usage: gitsync [COMMAND]

Commands:
  (no command)        Syncs the current Git repository (auto-add, commit if changes, pull --rebase, push).
  --id                Interactive repo initialization (create .git_ID files).
  --update-readme     Generate/update README.md scripts table from top-level files and commit+push it.
  --help              Show this help message.
USAGE
}

main() {
  case "${1:-}" in
    --id) initialize_repos ;;
    --update-readme) update_readme ;;
    --help) show_usage ;;
    "") sync_repo ;;
    *) log_message "ERROR" "Unknown command: $1"; show_usage; exit 1 ;;
  esac
}

main "$@"
