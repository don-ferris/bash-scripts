#!/usr/bin/env bash
: <<'SCRIPT_HEADER'
ai_prompts.sh - Menu system for managing frequently used Copilot prompts, placing them on the clipboard for quickly pasting into the prompt field. Run with -h to see all runtime options.
──────────────────────────────────────────────────────
Author: Don Ferris/GitHub Copilot  https://github.com/copilot/c/ba352956-6c0a-4180-8b7c-cce8d08e760f
Created: 2025-10-23
Current Revision: v1.6
──────────────────────────────────────────────────────
Revision History
================
v1.6 — 2025-10-26 — Improved aesthetics: clear the screen and draw a full-width extended-ASCII title box before showing the menu (applies to main interactive run and post-management single selection).

v1.5 — 2025-10-25 — Added -s option to open the ai_prompts.sh script itself in nano (edit script).

v1.4 — 2025-10-25 — After management operations (-a, -d, -k, -m, -z) redisplay the main menu and prompt for a selection so newly-created/changed items can be tested immediately. Added interactive_once() helper and adjusted control flow to return to a single interactive selection after the listed management operations.

v1.3.1 — 2025-10-25 — Fixed load_prompts variable-scope bug that could clobber caller variables (use local parsing variables/pkey); corrected stray printf typo that caused a shell syntax error; kept clipboard persistence behavior.

v1.3 — 2025-10-25 — Ensure clipboard ownership persists after the script exits by backgrounding xclip (uses setsid or nohup + disown); copy path updated to keep xclip process alive so pasted contents reflect the newly copied prompt.

v1.2 — 2025-10-25 — Simplified add/modify flows to single-line expanded-text entry only; prompt text changed to: "Enter expanded text (single line). Use '\t' for TAB and '\n' for NEWLINE."

v1.1 — 2025-10-25 — Move xclip availability check earlier (before showing interactive menu); if xclip cannot be installed, warn the user but continue to show the menu and fall back to printing the selected prompt to stdout instead of aborting.

v1.0 — 2025-10-24 — Initial implementation: 3-column interactive menu (keys 0–9, A–Z), backup .ai_prompts on each run (for -z undo functionality), add/delete/edit/change-key/modify management commands, xclip auto-install (if necessary), and printf '%b' handling of stored \n and \t sequences.
──────────────────────────────────────────────────────

# END OF
SCRIPT_HEADER

#   ┌─────────────────────────────┐
#   │        BEGIN  SCRIPT        │
#   └─────────────────────────────┘

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROMPTS_FILE="$SCRIPT_DIR/.ai_prompts"
BACKUP_FILE="$SCRIPT_DIR/.ai_prompts.bak"
MAX_ITEMS=36

KEYS=(0 1 2 3 4 5 6 7 8 9 \
      A B C D E F G H I J K L M N O P Q R S T U V W X Y Z)

declare -A MENU
declare -A EXPAN

CLIP_AVAILABLE=""

usage() {
  cat <<'EOF'
Usage: ai_prompts.sh [options]

Options:
  -a            Add a new prompt (interactive)
  -d            Delete an existing prompt (use -p to specify key or select interactively)
  -e            Edit the .ai_prompts file in nano
  -h            Show this help and exit
  -k            Change the key selector for an existing menu item (use -p to target or select)
  -m            Modify the menu text and/or expanded text for an existing item (use -p or select)
  -p KEY        Target a prompt by key (0-9 or A-Z). Case-insensitive.
  -s            Edit this script (ai_prompts.sh) in nano
  -z            Undo last add/delete/modify/change-key (restore .ai_prompts.bak)

If no management flags are provided, the script displays the menu,
waits for a single keypress (0-9 or A-Z), copies the associated expanded text to the clipboard (if available) or prints it to stdout (if clipboard not available), and exits.

File format for $PROMPTS_FILE:

[K] | menu text | expanded text
  - Enter expanded text as a single line. Use '\t' for TAB and '\n' for NEWLINE.
EOF
}

ensure_xclip() {
  if command -v xclip >/dev/null 2>&1; then
    return 0
  fi
  echo "xclip not found. Attempting to install xclip via apt (sudo)..."
  if sudo apt-get update -y >/dev/null 2>&1; then :; fi
  if sudo apt-get install -y xclip >/dev/null 2>&1; then
    echo "xclip installed."
    return 0
  else
    echo "Could not install xclip automatically."
    return 1
  fi
}

trim() {
  local var="$*"
  var="${var#"${var%%[![:space:]]*}"}"
  var="${var%"${var##*[![:space:]]}"}"
  printf '%s' "$var"
}

backup_prompts() {
  if [ -f "$PROMPTS_FILE" ]; then
    cp -f "$PROMPTS_FILE" "$BACKUP_FILE"
  else
    : > "$BACKUP_FILE"
  fi
}

# Load .ai_prompts into MENU and EXPAN.
# Important: use local variables to avoid clobbering caller scope (fixed bug).
load_prompts() {
  local line part1 part2 part3 key_raw menu_raw expanded_raw pkey
  MENU=()
  EXPAN=()
  if [ ! -f "$PROMPTS_FILE" ]; then
    cat > "$PROMPTS_FILE" <<'SAMPLE'
[F] | Post full script | Please post the complete, revised script every time modifications are made.
SAMPLE
  fi

  while IFS= read -r line || [ -n "$line" ]; do
    [[ -z "${line// }" ]] && continue
    [[ "${line## }" =~ ^# ]] && continue

    IFS='|' read -r part1 part2 part3 <<< "$line"

    key_raw="$(trim "$part1")"
    menu_raw="$(trim "$part2")"
    expanded_raw="$(trim "$part3")"

    # Normalize key: remove surrounding [] if present and uppercase
    pkey="${key_raw#[}"
    pkey="${pkey%]}"
    pkey="$(printf '%s' "$pkey" | tr '[:lower:]' '[:upper:]')"

    if [[ ! "$pkey" =~ ^[0-9A-Z]$ ]]; then
      echo "Warning: ignoring invalid key '$pkey' in line: $line" >&2
      continue
    fi

    MENU[$pkey]="$menu_raw"
    EXPAN[$pkey]="$expanded_raw"
  done < "$PROMPTS_FILE"
}

save_prompts_sorted() {
  local tmpfile k
  tmpfile="$(mktemp "$PROMPTS_FILE.XXXXXX")"
  for k in "${KEYS[@]}"; do
    if [ -n "${MENU[$k]+set}" ]; then
      printf '[%s] | %s | %s\n' "$k" "${MENU[$k]}" "${EXPAN[$k]}" >> "$tmpfile"
    fi
  done
  mv -f "$tmpfile" "$PROMPTS_FILE"
}

display_menu_3col() {
  local items=() k cols percol colwidths idx len item r c total
  for k in "${KEYS[@]}"; do
    if [ -n "${MENU[$k]+set}" ]; then
      items+=("[$k] ${MENU[$k]}")
    fi
  done
  total=${#items[@]}
  if [ "$total" -eq 0 ]; then
    echo "No prompts configured in $PROMPTS_FILE"
    return 0
  fi
  cols=3
  percol=$(( (total + cols - 1) / cols ))
  colwidths=(0 0 0)
  for ((c=0;c<cols;c++)); do
    for ((r=0;r<percol;r++)); do
      idx=$(( c*percol + r ))
      if [ $idx -lt $total ]; then
        len=${#items[$idx]}
        if [ $len -gt ${colwidths[$c]} ]; then
          colwidths[$c]=$len
        fi
      fi
    done
  done
  for ((r=0;r<percol;r++)); do
    for ((c=0;c<cols;c++)); do
      idx=$(( c*percol + r ))
      if [ $idx -lt $total ]; then
        item="${items[$idx]}"
        printf "%-*s    " $((colwidths[$c])) "$item"
      fi
    done
    echo
  done
}

# Draw a full-width title box using extended ASCII characters.
draw_title() {
  local cols title_disp title_len inner_width left_pad right_pad hchar vchar tl tr bl br pad_char i
  cols="$(tput cols 2>/dev/null || printf 80)"
  # Preserve exact spacing requested
  title_disp="     A I    P R O M P T S     "
  title_len=${#title_disp}
  inner_width=$((cols - 2))   # inside the box between the vertical edges
  if [ "$inner_width" -lt "$title_len" ]; then
    # if terminal is too narrow, truncate the title_disp
    title_disp="${title_disp:0:$inner_width}"
    title_len=${#title_disp}
  fi

  # Unicode box drawing / pad characters using $'...' to avoid locale/encoding issues
  hchar=$'\u2550'   # ═
  tl=$'\u2554'      # ╔
  tr=$'\u2557'      # ╗
  bl=$'\u255A'      # ╚
  br=$'\u255D'      # ╝
  vchar=$'\u2551'   # ║
  pad_char=$'\u2592' # ▒

  # top border
  printf '%s' "$tl"
  for ((i=0;i<inner_width;i++)); do printf '%s' "$hchar"; done
  printf '%s\n' "$tr"

  # middle line: left fill, title centered, right fill
  left_pad=$(( (inner_width - title_len) / 2 ))
  right_pad=$(( inner_width - title_len - left_pad ))
  printf '%s' "$vchar"
  for ((i=0;i<left_pad;i++)); do printf '%s' "$pad_char"; done
  printf '%s' "$title_disp"
  for ((i=0;i<right_pad;i++)); do printf '%s' "$pad_char"; done
  printf '%s\n' "$vchar"

  # bottom border
  printf '%s' "$bl"
  for ((i=0;i<inner_width;i++)); do printf '%s' "$hchar"; done
  printf '%s\n' "$br"
}




SELECTED_KEY=""
select_key_interactive() {
  echo
  echo "Press the key for the desired prompt (0-9 or A-Z), or press Esc to cancel:"
  # read a single keystroke (including Esc)
  IFS= read -r -n1 -s key
  if [ -z "$key" ]; then
    IFS= read -r -n1 -s key
  fi
  printf '\n'
  # If key is Esc (ASCII 27), suppress the Invalid-key message and return canceled.
  if [ "$key" = $'\e' ]; then
    echo "Cancelled."
    return 1
  fi
  key="$(printf '%s' "$key" | tr '[:lower:]' '[:upper:]')"
  if [[ ! "$key" =~ ^[0-9A-Z]$ ]]; then
    echo "Invalid key: $key"
    return 1
  fi
  if [ -z "${MENU[$key]+set}" ]; then
    echo "No prompt assigned to [$key]."
    return 1
  fi
  SELECTED_KEY="$key"
  return 0
}

# Add a new prompt (single-line expanded text only)
add_prompt_interactive() {
  local key key_in menu_text expanded_text k
  load_prompts
  if [ "${#MENU[@]}" -ge "$MAX_ITEMS" ]; then
    echo "Maximum number of prompts ($MAX_ITEMS) reached. Delete one before adding."
    return 1
  fi
  backup_prompts

  echo "Enter desired key for the new prompt (0-9 or A-Z). Leave empty to auto-pick the first available."
  read -r -p "Key: " key_in
  if [ -n "$key_in" ]; then
    key="$(printf '%s' "$key_in" | tr '[:lower:]' '[:upper:]' | tr -d '[:space:]')"
    if [[ ! "$key" =~ ^[0-9A-Z]$ ]]; then
      echo "Invalid key. Aborting."
      return 1
    fi
    if [ -n "${MENU[$key]+set}" ]; then
      echo "[$key] is already assigned to \"${MENU[$key]}\". You'll need to reassign another key selector for that menu item before you can reassign [$key]."
      return 1
    fi
  else
    key=""
    for k in "${KEYS[@]}"; do
      if [ -z "${MENU[$k]+set}" ]; then
        key="$k"
        break
      fi
    done
    if [ -z "$key" ]; then
      echo "No available keys. Aborting."
      return 1
    fi
    echo "Auto-selected key: [$key]"
  fi

  read -r -p "Menu text (short label shown in menu): " menu_text
  echo
  echo "Enter expanded text (single line). Use '\\t' for TAB and '\\n' for NEWLINE."
  read -r -p "Expanded text: " expanded_text

  if [ -z "$expanded_text" ]; then
    echo "No expanded text entered. Aborting."
    return 1
  fi

  MENU[$key]="$menu_text"
  EXPAN[$key]="$expanded_text"
  save_prompts_sorted
  echo "Added prompt [$key] ${menu_text}"
  return 0
}

delete_prompt() {
  local target yn
  load_prompts
  target="$1"
  if [ -z "$target" ]; then
    display_menu_3col
    if ! select_key_interactive; then
      return 1
    fi
    target="$SELECTED_KEY"
  else
    target="$(printf '%s' "$target" | tr '[:lower:]' '[:upper:]')"
    if [[ ! "$target" =~ ^[0-9A-Z]$ ]] || [ -z "${MENU[$target]+set}" ]; then
      echo "Invalid or unassigned key: $target"
      return 1
    fi
  fi
  backup_prompts
  read -r -p "Delete [$target] \"${MENU[$target]}\" ? [y/N] " yn
  case "$yn" in
    [Yy]*)
      unset MENU[$target]
      unset EXPAN[$target]
      save_prompts_sorted
      echo "Deleted [$target]."
      return 0
      ;;
    *)
      echo "Aborted."
      return 1
      ;;
  esac
}

modify_prompt() {
  local target new_menu new_expanded
  load_prompts
  target="$1"
  if [ -z "$target" ]; then
    display_menu_3col
    if ! select_key_interactive; then
      return 1
    fi
    target="$SELECTED_KEY"
  else
    target="$(printf '%s' "$target" | tr '[:lower:]' '[:upper:]')"
    if [[ ! "$target" =~ ^[0-9A-Z]$ ]] || [ -z "${MENU[$target]+set}" ]; then
      echo "Invalid or unassigned key: $target"
      return 1
    fi
  fi
  backup_prompts
  echo "Current menu text: ${MENU[$target]}"
  read -r -p "New menu text (leave empty to keep current): " new_menu
  if [ -n "$new_menu" ]; then
    MENU[$target]="$new_menu"
  fi
  echo
  echo "Current expanded text (stored with literal \\n and \\t sequences):"
  echo "${EXPAN[$target]}"
  echo
  echo "Enter new expanded text (single line). Use '\\t' for TAB and '\\n' for NEWLINE."
  read -r -p "Expanded text (leave empty to keep current): " new_expanded
  if [ -n "$new_expanded" ]; then
    EXPAN[$target]="$new_expanded"
  fi
  save_prompts_sorted
  echo "Modified [$target]."
  return 0
}

change_key() {
  local source newkey_in newkey
  load_prompts
  source="$1"
  if [ -z "$source" ]; then
    display_menu_3col
    if ! select_key_interactive; then
      return 1
    fi
    source="$SELECTED_KEY"
  else
    source="$(printf '%s' "$source" | tr '[:lower:]' '[:upper:]')"
    if [[ ! "$source" =~ ^[0-9A-Z]$ ]] || [ -z "${MENU[$source]+set}" ]; then
      echo "Invalid or unassigned key: $source"
      return 1
    fi
  fi
  echo "Selected [$source] \"${MENU[$source]}\"."
  read -r -p "Enter new key to assign to this item (0-9 or A-Z): " newkey_in
  newkey="$(printf '%s' "$newkey_in" | tr '[:lower:]' '[:upper:]' | tr -d '[:space:]')"
  if [[ ! "$newkey" =~ ^[0-9A-Z]$ ]]; then
    echo "Invalid key: $newkey"
    return 1
  fi
  if [ "$newkey" = "$source" ]; then
    echo "New key is the same as current key. Nothing to do."
    return 0
  fi
  if [ -n "${MENU[$newkey]+set}" ]; then
    echo "[$newkey] is already assigned to \"${MENU[$newkey]}\"."
    echo "You'll need to reassign another key selector for that menu item before you can reassign [$newkey]."
    return 1
  fi
  backup_prompts
  MENU[$newkey]="${MENU[$source]}"
  EXPAN[$newkey]="${EXPAN[$source]}"
  unset MENU[$source]
  unset EXPAN[$source]
  save_prompts_sorted
  echo "Reassigned [$source] -> [$newkey]."
  return 0
}

undo_last() {
  if [ ! -f "$BACKUP_FILE" ]; then
    echo "No backup ($BACKUP_FILE) found to restore."
    return 1
  fi
  cp -f "$BACKUP_FILE" "$PROMPTS_FILE"
  echo "Restored $PROMPTS_FILE from $BACKUP_FILE."
  return 0
}

# Copy or print: If CLIP_AVAILABLE == 1 use xclip; otherwise print to stdout.
# Use setsid/nohup so the xclip process persists and owns the selection.
copy_key_to_clipboard() {
  local selkey stored content
  selkey="$1"
  load_prompts
  if [ -z "${MENU[$selkey]+set}" ]; then
    echo "No prompt for key [$selkey]."
    return 1
  fi
  stored="${EXPAN[$selkey]}"
  content="$(printf '%b' "$stored")"
  if [ "${CLIP_AVAILABLE:-}" = "1" ]; then
    if command -v setsid >/dev/null 2>&1; then
      printf '%s' "$content" | setsid xclip -selection clipboard -i >/dev/null 2>&1 &
      disown
      echo "Copied prompt [$selkey] \"${MENU[$selkey]}\" to clipboard."
      return 0
    else
      printf '%s' "$content" | nohup xclip -selection clipboard -i >/dev/null 2>&1 &
      disown
      echo "Copied prompt [$selkey] \"${MENU[$selkey]}\" to clipboard."
      return 0
    fi
  fi
  if ensure_xclip; then
    CLIP_AVAILABLE=1
    if command -v setsid >/dev/null 2>&1; then
      printf '%s' "$content" | setsid xclip -selection clipboard -i >/dev/null 2>&1 &
      disown
      echo "Copied prompt [$selkey] \"${MENU[$selkey]}\" to clipboard."
      return 0
    else
      printf '%s' "$content" | nohup xclip -selection clipboard -i >/dev/null 2>&1 &
      disown
      echo "Copied prompt [$selkey] \"${MENU[$selkey]}\" to clipboard."
      return 0
    fi
  fi
  echo "Warning: clipboard utility xclip is not available; printing prompt to stdout:"
  echo
  printf '%s\n' "$content"
  return 0
}

# Show the menu once and prompt for a single selection (used after management ops).
interactive_once() {
  # clear screen and draw title box
  clear
  draw_title
  echo

  load_prompts
  if ensure_xclip; then
    CLIP_AVAILABLE=1
  else
    CLIP_AVAILABLE=0
    echo "Warning: clipboard utility xclip is not available and could not be installed."
    echo "Selections will be printed to stdout instead of copied to the clipboard."
    echo
  fi

  display_menu_3col
  echo
  echo "Select a prompt by pressing its key (0-9 or A-Z), or press Esc to cancel."
  IFS= read -r -n1 -s key
  if [ -z "$key" ]; then
    IFS= read -r -n1 -s key
  fi
  printf '\n'
  if [ "$key" = $'\e' ]; then
    echo "Cancelled."
    return 0
  fi
  key="$(printf '%s' "$key" | tr '[:lower:]' '[:upper:]')"
  if [[ ! "$key" =~ ^[0-9A-Z]$ ]]; then
    echo "Invalid key."
    return 1
  fi
  if ! copy_key_to_clipboard "$key"; then
    return 2
  fi
  return 0
}

# ---------- Main ----------
if [ $# -eq 0 ]; then
  # clear screen and draw title box
  clear
  draw_title
  echo

  load_prompts
  if ensure_xclip; then
    CLIP_AVAILABLE=1
  else
    CLIP_AVAILABLE=0
    echo "Warning: clipboard utility xclip is not available and could not be installed."
    echo "Selections will be printed to stdout instead of copied to the clipboard."
    echo
  fi

  display_menu_3col
  echo
  echo "Select a prompt by pressing its key (0-9 or A-Z), or press Esc to cancel."
  IFS= read -r -n1 -s key
  if [ -z "$key" ]; then
    IFS= read -r -n1 -s key
  fi
  printf '\n'
  if [ "$key" = $'\e' ]; then
    echo "Cancelled."
    exit 0
  fi
  key="$(printf '%s' "$key" | tr '[:lower:]' '[:upper:]')"
  if [[ ! "$key" =~ ^[0-9A-Z]$ ]]; then
    echo "Invalid key."
    exit 1
  fi
  if ! copy_key_to_clipboard "$key"; then
    exit 2
  fi
  exit 0
fi

# (management flags handling - now some operations will display the menu once afterwards)
TARGET_KEY=""
OP_ADD=0; OP_DEL=0; OP_EDIT_FILE=0; OP_EDIT_SCRIPT=0; OP_KEYCHANGE=0; OP_MODIFY=0; OP_UNDO=0; SHOW_HELP=0

while getopts ":adekmhp:zs" opt; do
  case $opt in
    a) OP_ADD=1 ;;
    d) OP_DEL=1 ;;
    e) OP_EDIT_FILE=1 ;;
    k) OP_KEYCHANGE=1 ;;
    m) OP_MODIFY=1 ;;
    p) TARGET_KEY="$OPTARG" ;;
    z) OP_UNDO=1 ;;
    s) OP_EDIT_SCRIPT=1 ;;
    h) SHOW_HELP=1 ;;
    \?)
      echo "Unknown option: -$OPTARG" >&2
      usage
      exit 1
      ;;
    :)
      echo "Option -$OPTARG requires an argument." >&2
      usage
      exit 1
      ;;
  esac
done

# manual parse for -p if not caught by getopts (allow -pKEY or -p KEY)
if [ -z "${TARGET_KEY:-}" ]; then
  args=("$@")
  for ((i=0;i<${#args[@]};i++)); do
    a="${args[$i]}"
    if [ "$a" = "-p" ]; then
      next=$((i+1))
      if [ $next -lt ${#args[@]} ]; then
        TARGET_KEY="${args[$next]}"
      fi
    elif [[ "$a" == -p* && "$a" != "-p" ]]; then
      TARGET_KEY="${a#-p}"
    fi
  done
fi

if [ "$SHOW_HELP" -eq 1 ]; then usage; exit 0; fi

if [ "$OP_UNDO" -eq 1 ]; then
  if undo_last; then
    # After undo, show menu and allow one selection to test
    interactive_once
    exit $?
  else
    exit 1
  fi
fi

if [ "$OP_EDIT_FILE" -eq 1 ]; then
  backup_prompts
  mkdir -p "$SCRIPT_DIR"
  nano "$PROMPTS_FILE"
  load_prompts
  save_prompts_sorted
  echo "Edited $PROMPTS_FILE and saved sorted result."
  exit 0
fi

if [ "$OP_EDIT_SCRIPT" -eq 1 ]; then
  # Backup the script itself, then open it for editing
  cp -f "${BASH_SOURCE[0]}" "${BASH_SOURCE[0]}.bak" 2>/dev/null || true
  nano "$SCRIPT_DIR/ai_prompts.sh"
  echo "Edited $SCRIPT_DIR/ai_prompts.sh"
  exit 0
fi

if [ "$OP_ADD" -eq 1 ]; then
  if add_prompt_interactive; then
    # After adding, let the user immediately test by showing the menu and prompting once
    interactive_once
    exit $?
  else
    exit 1
  fi
fi

if [ "$OP_DEL" -eq 1 ]; then
  if delete_prompt "$TARGET_KEY"; then
    interactive_once
    exit $?
  else
    exit 1
  fi
fi

if [ "$OP_KEYCHANGE" -eq 1 ]; then
  if change_key "$TARGET_KEY"; then
    interactive_once
    exit $?
  else
    exit 1
  fi
fi

if [ "$OP_MODIFY" -eq 1 ]; then
  if modify_prompt "$TARGET_KEY"; then
    interactive_once
    exit $?
  else
    exit 1
  fi
fi

echo "No valid operation specified."
usage
exit 1
>>>>>>> a6e0531 (script_template.sh: made changes to standardized script header formatting, using multi-line comment)
